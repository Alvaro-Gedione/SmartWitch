<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SmartWitch - Capturador de Movimentos Mágicos</title>
    <link rel="icon" href="src/Img/Logo.png" type="image/png">
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Cinzel+Decorative:wght@400;700;900&family=Cormorant+Garamond:wght@300;400;500;600;700&display=swap');
        
        :root {
            --primary: #5d2751;
            --secondary: #b13e53;
            --accent: #ef7d57;
            --dark: #1a1a2e;
            --light: #f8f1ff;
        }
        
        body {
            font-family: 'Cormorant Garamond', serif;
            background-color: var(--dark);
            color: var(--light);
            background-image: url('https://www.transparenttextures.com/patterns/black-paper.png');
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 20px;
            box-sizing: border-box;
        }
        
        .magic-font {
            font-family: 'Cinzel Decorative', cursive;
        }

        .ancient-paper {
            background-image: url('https://www.transparenttextures.com/patterns/rice-paper-3.png');
            background-color: #f5e7c1;
            color: #3a2810;
            border-radius: 5px;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.5);
            position: relative;
            overflow: hidden;
            max-width: 700px;
            width: 100%;
        }
        
        .ancient-paper::before {
            content: "";
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(0deg, transparent 95%, rgba(0,0,0,0.1) 96%, transparent 97%),
                                 linear-gradient(90deg, transparent 95%, rgba(0,0,0,0.1) 96%, transparent 97%);
            background-size: 20px 20px;
            pointer-events: none;
        }

        #areaCaptura {
            width: 100%;
            height: 300px;
            border: 2px dashed var(--secondary);
            margin: 20px auto;
            position: relative;
            background-color: rgba(29, 29, 59, 0.5);
            cursor: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><path fill="%23ef7d57" d="M20.84 22.73L18.11 20H17V15.89L15 13.89V17H13V12.89L11 10.89V17H9V9.89L7 7.89V17H5V7.89L2.11 5L3.5 3.61L22.11 22.22L20.84 22.73M17 8V5H15V8H17M17 3H21V7H19L17.5 5.5L17 3M7 3V5H5V3H7M13 3V5H11V3H13M19 13V11H21V13H19M19 9V7H21V9H19M13 7V5H11V7H13M13 11V9H11V11H13Z"/></svg>') 5 5, crosshair;
            border-radius: 0.5rem;
            overflow: hidden;
        }
        #areaCaptura.capturing {
            border-color: var(--accent);
        }
        #areaCaptura.prepared {
            border-color: var(--secondary);
        }
        
        .capture-button {
            padding: 10px 20px;
            margin: 10px;
            cursor: pointer;
            border-radius: 0.5rem;
            font-weight: 600;
            transition: all 0.2s ease;
        }

        .capture-button-primary {
            background-color: var(--primary);
            color: var(--light);
        }
        .capture-button-primary:hover {
            background-color: #7a356e;
        }

        .capture-button-secondary {
            background-color: var(--secondary);
            color: var(--light);
        }
        .capture-button-secondary:hover {
            background-color: #d14a60;
        }

        .capture-button-danger {
            background-color: #dc2626;
            color: var(--light);
        }
        .capture-button-danger:hover {
            background-color: #b91c1c;
        }

        .capture-button-success {
            background-color: #16a34a;
            color: var(--light);
        }
        .capture-button-success:hover {
            background-color: #15803d;
        }

        #status {
            margin-top: 20px;
            font-weight: bold;
            min-height: 40px;
            color: #3a2810;
        }
        #menuMovimentos {
            margin: 20px auto;
            padding: 15px;
            border: 1px solid var(--secondary);
            max-width: 500px;
            text-align: left;
            border-radius: 0.5rem;
            background-color: rgba(29, 29, 59, 0.7);
        }
        .movimento-item {
            padding: 8px 10px;
            margin: 5px 0;
            border-bottom: 1px solid rgba(255,255,255,0.1);
            cursor: pointer;
            color: var(--light);
            border-radius: 0.3rem;
        }
        .movimento-item:last-child {
            border-bottom: none;
        }
        .movimento-item:hover {
            background-color: rgba(255,255,255,0.1);
        }
        .movimento-item.selected {
            background-color: rgba(93, 39, 81, 0.7);
            border: 1px solid var(--accent);
        }
        #controles {
            display: flex;
            justify-content: center;
            flex-wrap: wrap;
        }
        .grupo-controles {
            margin: 0 15px;
            display: flex;
            gap: 10px;
        }
        #ponto-inicial {
            width: 10px;
            height: 10px;
            background-color: #10b981;
            border-radius: 50%;
            position: absolute;
            z-index: 10;
        }
        .drawn-point {
            width: 6px;
            height: 6px;
            background-color: #3b82f6;
            position: absolute;
            border-radius: 50%;
            opacity: 0.8;
        }
        .replay-cursor {
            width: 16px;
            height: 16px;
            background-color: #ef4444;
            border-radius: 50%;
            position: absolute;
            z-index: 10;
            box-shadow: 0 0 5px rgba(239, 68, 68, 0.7);
        }

        /* Scrollbar for movement list */
        .scroll-container-mc {
            scrollbar-width: thin;
            scrollbar-color: var(--secondary) rgba(29, 29, 59, 0.7);
        }
        
        .scroll-container-mc::-webkit-scrollbar {
            width: 8px;
        }
        
        .scroll-container-mc::-webkit-scrollbar-track {
            background: rgba(29, 29, 59, 0.7);
        }
        
        .scroll-container-mc::-webkit-scrollbar-thumb {
            background-color: var(--secondary);
            border-radius: 10px;
        }
        
        /* Input styling */
        #comando {
            background-color: rgba(245, 231, 193, 0.8);
            border: 1px solid #a78bfa;
            color: #3a2810;
        }
        #comando:focus {
            outline: none;
            border-color: var(--accent);
            box-shadow: 0 0 0 2px rgba(239, 125, 87, 0.3);
        }
    </style>
</head>
<body>
    <div class="ancient-paper p-8 text-center">
        <h1 class="magic-font text-3xl font-bold mb-6 text-gray-800">Capturador de Movimentos Mágicos</h1>
        <p class="text-gray-700 mb-4">Pressione e segure o botão do mouse na área abaixo para capturar um movimento:</p>
        
        <div id="areaCaptura" class="mb-4"></div>
        
        <div id="controles" class="flex flex-col sm:flex-row justify-center items-center mb-6 gap-4">
            <div class="grupo-controles">
                <button id="btnIniciar" class="capture-button capture-button-primary">Preparar Captura</button>
                <button id="btnParar" disabled class="capture-button capture-button-danger">Finalizar Captura</button>
            </div>
            <div class="grupo-controles">
                <button id="btnCarregar" class="capture-button capture-button-secondary">Carregar Movimentos</button>
                <button id="btnRepetir" disabled class="capture-button capture-button-success">Repetir Movimento</button>
            </div>
        </div>
        
        <div class="mb-6">
            <label for="comando" class="block text-sm font-medium mb-2 text-gray-700">Comando Associado:</label>
            <input type="text" id="comando" placeholder="Digite o comando para este movimento" class="w-full px-4 py-2 border rounded focus:outline-none focus:ring-1 focus:ring-purple-500 text-gray-800">
        </div>
        
        <div id="menuMovimentos" class="hidden text-gray-800">
            <h3 class="font-bold text-lg mb-2 magic-font">Movimentos Cadastrados</h3>
            <div id="listaMovimentos" class="max-h-60 overflow-y-auto scroll-container-mc"></div>
        </div>

        <div id="status" class="text-lg text-gray-700 mt-4">Pronto para começar</div>
    </div>
    
    <script>
        // Variáveis globais
        let preparadoParaCaptura = false;
        let capturando = false;
        let movimentos = [];
        let inicioCaptura;
        let timeoutRepeticao;
        let comandosCadastrados = [];
        let movimentoSelecionado = null;
        
        // Elementos da página
        const areaCaptura = document.getElementById('areaCaptura');
        const btnIniciar = document.getElementById('btnIniciar');
        const btnParar = document.getElementById('btnParar');
        const btnRepetir = document.getElementById('btnRepetir');
        const btnCarregar = document.getElementById('btnCarregar');
        const inputComando = document.getElementById('comando');
        const statusElement = document.getElementById('status');
        const menuMovimentos = document.getElementById('menuMovimentos');
        const listaMovimentos = document.getElementById('listaMovimentos');
        
        // Carrega comandos cadastrados ao iniciar
        function carregarComandos() {
            google.script.run.withSuccessHandler(function(comandos) {
                comandosCadastrados = comandos;
                statusElement.textContent = 'Comandos carregados!';
                atualizarListaMovimentos();
            }).withFailureHandler(function(err) {
                console.error('Erro ao carregar comandos:', err);
                // Fallback para dados de demonstração se houver erro
                comandosCadastrados = [
                    { comando: "Lumos", coordenadas: [{x: 50, y:50, t:0}, {x:100, y:50, t:100}, {x:75,y:100,t:200}, {x:50,y:50,t:300}], duracao: 0.3, comandoAssociado: "Lumos" },
                    { comando: "Expelliarmus", coordenadas: [{x: 20, y:80, t:0}, {x:120, y:20, t:200}, {x:20,y:20,t:400}], duracao: 0.4, comandoAssociado: "Expelliarmus" },
                    { comando: "Reparo", coordenadas: [{x: 50, y:50, t:0}, {x:70, y:30, t:100}, {x:90,y:50,t:200}, {x:70,y:70,t:300}, {x:50,y:50,t:400}], duracao: 0.4, comandoAssociado: "Reparo" }
                ];
                statusElement.textContent = 'Comandos de exemplo carregados (modo offline)';
                atualizarListaMovimentos();
            }).listarComandos();
        }
        
        // Mostra/oculta o menu de movimentos
        btnCarregar.addEventListener('click', function() {
            if (menuMovimentos.classList.contains('hidden')) {
                carregarComandos();
                menuMovimentos.classList.remove('hidden');
                btnCarregar.textContent = 'Ocultar Movimentos';
            } else {
                menuMovimentos.classList.add('hidden');
                btnCarregar.textContent = 'Carregar Movimentos';
            }
        });
        
        // Atualiza a lista de movimentos
        function atualizarListaMovimentos() {
            listaMovimentos.innerHTML = '';
            
            if (comandosCadastrados.length === 0) {
                listaMovimentos.innerHTML = '<p class="text-gray-600">Nenhum movimento cadastrado ainda.</p>';
                return;
            }
            
            comandosCadastrados.forEach(function(cmd, index) {
                const item = document.createElement('div');
                item.className = 'movimento-item';
                item.textContent = `Movimento ${index + 1} (${cmd.comandoAssociado || cmd.comando || 'Sem comando'})`;
                
                item.addEventListener('click', function() {
                    movimentoSelecionado = cmd;
                    inputComando.value = cmd.comandoAssociado || cmd.comando || '';
                    statusElement.textContent = `Movimento ${index + 1} selecionado! Clique em "Repetir Movimento" para visualizá-lo.`;
                    
                    // Destaca o item selecionado
                    document.querySelectorAll('.movimento-item').forEach(el => {
                        el.classList.remove('selected');
                    });
                    item.classList.add('selected');
                });
                
                listaMovimentos.appendChild(item);
            });
        }
        
        // Evento de preparação para captura
        btnIniciar.addEventListener('click', function() {
            preparadoParaCaptura = true;
            movimentos = [];
            btnIniciar.disabled = true;
            btnParar.disabled = false;
            btnRepetir.disabled = true;
            statusElement.textContent = 'Clique e segure na área de captura para começar a gravar...';
            areaCaptura.classList.remove('prepared');
            areaCaptura.classList.add('prepared');
            areaCaptura.innerHTML = '';
        });
        
        // Evento de primeiro clique para iniciar captura
        areaCaptura.addEventListener('mousedown', function(e) {
            if (!preparadoParaCaptura || e.button !== 0) return; // Só botão esquerdo
            
            capturando = true;
            inicioCaptura = Date.now();
            statusElement.textContent = 'Capturando movimento... Solte o botão para parar.';
            areaCaptura.classList.remove('prepared');
            areaCaptura.classList.add('capturing');
            
            // Registra o primeiro ponto
            const rect = areaCaptura.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            movimentos.push({ x, y, t: 0 });
            
            // Desenha o primeiro ponto
            const ponto = document.createElement('div');
            ponto.id = 'ponto-inicial';
            ponto.style.left = (x - 5) + 'px';
            ponto.style.top = (y - 5) + 'px';
            areaCaptura.appendChild(ponto);
        });
        
        // Evento de soltar o botão para parar captura
        areaCaptura.addEventListener('mouseup', function(e) {
            if (!capturando) return;
            
            finalizarCaptura();
        });
        
        // Evento de mouse saindo da área (para caso solte fora)
        areaCaptura.addEventListener('mouseleave', function(e) {
            if (capturando) {
                finalizarCaptura();
            }
            
            if (timeoutRepeticao) {
                clearTimeout(timeoutRepeticao);
                statusElement.textContent = 'Repetição interrompida';
            }
        });
        
        // Função para finalizar a captura
        function finalizarCaptura() {
            capturando = false;
            preparadoParaCaptura = false;
            btnIniciar.disabled = false;
            btnParar.disabled = true;
            btnRepetir.disabled = false;
            areaCaptura.classList.remove('capturing');
            areaCaptura.classList.remove('prepared');
            
            const duracao = (Date.now() - inicioCaptura) / 1000;
            statusElement.textContent = `Movimento capturado! Duração: ${duracao.toFixed(2)}s`;
            
            // Salva o movimento no Google Sheets
            const comando = inputComando.value.trim();
            const dadosMovimento = {
                tipo: 'movimento',
                coordenadas: movimentos,
                duracao: duracao,
                comandoAssociado: comando
            };
            
            google.script.run.withSuccessHandler(function() {
                statusElement.textContent += ' | Movimento salvo com sucesso!';
                carregarComandos(); // Atualiza a lista
            }).withFailureHandler(function(err) {
                console.error('Erro ao salvar movimento:', err);
                // Fallback para salvar localmente
                comandosCadastrados.push(dadosMovimento);
                statusElement.textContent += ' | Movimento salvo localmente (modo offline)';
                atualizarListaMovimentos();
            }).salvarMovimento(dadosMovimento);
        }
        
        // Evento de repetição de movimento
        btnRepetir.addEventListener('click', function() {
            const movimento = movimentoSelecionado || { coordenadas: movimentos };
            
            if (!movimento.coordenadas || movimento.coordenadas.length === 0) {
                statusElement.textContent = 'Nenhum movimento para repetir!';
                return;
            }
            
            // Limpa a área
            areaCaptura.innerHTML = '';
            statusElement.textContent = 'Repetindo movimento...';
            
            // Desenha o caminho completo em azul claro
            movimento.coordenadas.forEach(ponto => {
                const dot = document.createElement('div');
                dot.classList.add('drawn-point');
                dot.style.left = ponto.x + 'px';
                dot.style.top = ponto.y + 'px';
                dot.style.opacity = '0.3';
                areaCaptura.appendChild(dot);
            });
            
            // Cria um elemento para mostrar o movimento
            const cursor = document.createElement('div');
            cursor.classList.add('replay-cursor');
            areaCaptura.appendChild(cursor);
            
            // Repete o movimento
            let index = 0;
            const inicioRepeticao = Date.now();
            
            function animar() {
                if (index >= movimento.coordenadas.length) {
                    const duracao = (Date.now() - inicioRepeticao) / 1000;
                    statusElement.textContent = `Movimento repetido! Duração: ${duracao.toFixed(2)}s`;
                    
                    // Verifica se corresponde a algum comando cadastrado
                    if (!movimentoSelecionado) {
                        const comandoCorrespondente = encontrarComandoCorrespondente({
                            coordenadas: movimentos,
                            duracao: duracao
                        });
                        
                        if (comandoCorrespondente) {
                            statusElement.textContent += ` | Comando reconhecido: ${comandoCorrespondente}`;
                        } else {
                            statusElement.textContent += ` | Nenhum comando correspondente encontrado.`;
                        }
                    }
                    
                    return;
                }
                
                const ponto = movimento.coordenadas[index];
                cursor.style.left = (ponto.x - 8) + 'px';
                cursor.style.top = (ponto.y - 8) + 'px';
                
                index++;
                timeoutRepeticao = setTimeout(animar, 20);
            }
            
            animar();
        });
        
        // Captura movimentos do mouse enquanto o botão estiver pressionado
        areaCaptura.addEventListener('mousemove', function(e) {
            if (!capturando) return;
            
            const rect = areaCaptura.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            const tempo = Date.now() - inicioCaptura;
            
            movimentos.push({ x, y, t: tempo });
            
            // Desenha um ponto no caminho
            const ponto = document.createElement('div');
            ponto.classList.add('drawn-point');
            ponto.style.left = (x - 3) + 'px';
            ponto.style.top = (y - 3) + 'px';
            areaCaptura.appendChild(ponto);
        });
        
        // Função para encontrar comandos correspondentes
        function encontrarComandoCorrespondente(movimento) {
            for (const cmd of comandosCadastrados) {
                if (compararMovimentos(movimento.coordenadas, cmd.coordenadas)) {
                    return cmd.comandoAssociado || cmd.comando;
                }
            }
            return null;
        }
        
        // Função melhorada para comparar movimentos
        function compararMovimentos(mov1, mov2) {
            // Normaliza os movimentos para terem o mesmo número de pontos
            const normalized1 = normalizarMovimento(mov1);
            const normalized2 = normalizarMovimento(mov2);
            
            if (normalized1.length === 0 || normalized2.length === 0) return false;

            // Calcula a distância total do movimento para normalização
            const distanciaTotal1 = calcularDistanciaTotal(normalized1);
            const distanciaTotal2 = calcularDistanciaTotal(normalized2);
            
            const factorEscala = (distanciaTotal1 === 0 || distanciaTotal2 === 0) ? 1 : distanciaTotal2 / distanciaTotal1;
            
            const margemErro = 0.20 * Math.max(distanciaTotal1, distanciaTotal2, 100);
            let correspondencias = 0;
            
            for (let i = 0; i < normalized1.length; i++) {
                // Aplica escala para normalizar tamanhos diferentes
                const x1 = normalized1[i].x * factorEscala;
                const y1 = normalized1[i].y * factorEscala;
                
                const distancia = Math.sqrt(
                    Math.pow(x1 - normalized2[i].x, 2) +
                    Math.pow(y1 - normalized2[i].y, 2)
                );
                
                if (distancia <= margemErro) {
                    correspondencias++;
                }
            }
            
            // Considera correspondência se pelo menos 70% dos pontos estão dentro da margem
            return (correspondencias / normalized1.length) >= 0.70;
        }
        
        // Calcula a distância total percorrida no movimento
        function calcularDistanciaTotal(movimento) {
            let distancia = 0;
            if (movimento.length < 2) return 0;
            for (let i = 1; i < movimento.length; i++) {
                distancia += Math.sqrt(
                    Math.pow(movimento[i].x - movimento[i-1].x, 2) +
                    Math.pow(movimento[i].y - movimento[i-1].y, 2)
                );
            }
            return distancia;
        }
        
        // Normaliza movimento para 30 pontos para facilitar comparação
        function normalizarMovimento(movimento) {
            const numPontos = 30;
            const resultado = [];
            
            if (movimento.length === 0) return [];
            if (movimento.length <= numPontos) return movimento;
            
            for (let i = 0; i < numPontos; i++) {
                const index = Math.floor((i / (numPontos - 1)) * (movimento.length - 1));
                resultado.push(movimento[index]);
            }
            
            return resultado;
        }
        
        // Carrega comandos ao iniciar
        carregarComandos();
    </script>
</body>
</html>